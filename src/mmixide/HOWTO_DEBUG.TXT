This document describes the concepts behind the MMIXIDE debugger

1. The fetch perform loop

The core of the mmix simulator in mmix_main
is the fetch - perform loop. Which reads:
while (!halted)
{ mmix_fetch_instruction();
resume:
  mmix_perform_instruction(); 
  mmix_dynamic_trap();
  if (resuming)
  { if (op==RESUME) goto resume;
	else resuming=false;
  }
}

Two soubroutines do the tracing:
mmix_trace_fetch() and mmix_trace_perform()
The first should be called after the instruction is 
feteched, the second after it is performed.

So a short version with tracing enabled could read:
while (!halted)
{ mmix_fetch_instruction();
  mmix_trace_fetch(); 
resume:
  mmix_perform_instruction(); 
  mmix_trace_perform();
  mmix_dynamic_trap();
  if (resuming)
  { if (op==RESUME) goto resume;
	else resuming=false;
  }
}

2. User interaction
In interactive mode, we call the function 
mmix_interact, which calls mmix_stopped(loc) to position
the editor at the current location and waits for the gui
thread to call mmix_continue whict sets the debug mode
and signals the hInteract Mutex to allow the debugger to 
continue.

The loop then becomes
while (!halted)
{ mmix_fetch_instruction();
  mmix_trace_fetch(); 
  mmix_interact();
resume:
  mmix_perform_instruction(); 
  mmix_trace_perform();
  mmix_interact();
  mmix_dynamic_trap();
  if (resuming)
  { if (op==RESUME) goto resume;
	else resuming=false;
  }
}

The boolean variable interacting tells whether we are in interactive mode and should interact at all. But even in 
interactive mode, we do not want to interact allways.

The variable interact_after_break detemines whether
we interact at all for the current instruction.
The variable break_after determines whether we interact 
after performing the instruction or before performing
the instruction.

The two calls to  mmix_interact() then become after fetching:
	if (interact_after_break  && !break_after)
	{   mmix_interact(); 
	    interact_after_break=false; 
	}

And after performing:
    if (interact_after_break)
	{  mmix_interact();
	   interact_after_break=false;
	}

The test insurest that there is only one interaction per
instruction.

3. Selective tracing
The mmix variable tracing tells whether 
the current instruction must be traced.
A local variable fetch_traced tells whether 
fetching of the instruction was already traced.
In case we discover that we should trace an instruction
only after performing the instruction, we know what to do.

The two calls then become after fetching;
	if (tracing) 
	{ mmix_trace_fetch(); fetch_traced=true;}

	and 

	if (tracing)
	{ if (!fetch_traced) 
	  { mmix_trace_fetch(); fetch_traced=true; }
      mmix_trace_perform();
	  if (showing_stats) show_stats(breakpoint);
	}

Further, we switch on tracing when resuming:
    if (resuming)
	{ if (op==RESUME)
	  { fetch_traced=false;
	    goto resume;
	  }
	  else
	    resuming=false;
	}

4. Debug modes.
The function mmix_interact sets a variable called
dbg_mode, which can have values from the enumeration type
dbg_type. Lets start with discussing the basic values.

dbg_step: here we execute just one instruction (in case
of a resume possibly more) and interact again.
After fetching the instruction we consider the debug mode
using a switch (dbg_mode) and the case for dbg_step reads 
case dbg_step: tracing=interact_after_break=true; break;

dbg_cont: here we continue without further tracing or 
interaction. The only way to return to interaction is
then a breakpoint, discussed in the next section or
the break button or an interrupt. The case statement reads:
case dbg_cont: default: tracing=interact_after_break=false; break;

Another simple case is dbg_quit, when we terminate the simulation.
It reads
case dbg_quit: halted=true; goto end_simulation; 
 
4. Read, Write 	and Execute Breakpoints
We set the variable breakpoints to zero before fetching the instruction.

	    breakpoint=0;

After setting defaults based on the debug mode,
we investigate the breakpoint variable to see
whether the	defaults are augmented by 
breakpoint bits set by the instruction just fetched.
	
	if (breakpoint&exec_bit)  
		tracing=interact_after_break=true;
	if (breakpoint & trace_bit) 
		tracing=true;
And after performing the instruction, we have		
    if (breakpoint&(read_bit|write_bit))  
		tracing=interact_after_break=true;
				
5. Interrupts
Interrupts can occur in an interrupt handler or by pressing the
Break Button. The break button sets the value of interrupt to 
true as will do the interrupt handler.
We check for an interrupt after checking for breakpoints.		
	if (interrupt) 
		interacting=tracing=interact_after_break=true, interrupt=false;

6. Hiding the operating system
Hiding the operatings system can be done by setting the
variable show_operating_system to false on a global level
and it can be done by using the step over button for
an individual TRAP instruction.

Lets start with the latter.

The step over button sets the dbg_mode to dbg_over.
If the instruction after fetching turns out to be a TRAP,
we switch the mode to dbg_over_ftrap. In this mode
we run without tracing until we encounter a resume
and get back to the user program.
		
Let us first consider the case when break_after==true
and the mmix_interact after performing the previous instruction
returns dbg_over. We see this when checking the dbg_mode
at the beginning of the loop. We check that the instruction
is a TRAP and we are still in user space. We switch 
to dbg_over_ftrap and remember the trap location
because we want to position the editor on the
trap once we resume. While in dbg_over_ftrap mode we 
stop tracing and interacting as long as we are in the os.
	  case dbg_over:
		  if ((inst>>24)==TRAP && (loc.h&sign_bit)==0)
		  {  dbg_mode=dbg_over_ftrap;
		     trap_loc=loc;
             tracing= true; interact_after_break=false;
		  }
		  { dbg_mode=dbg_step; goto reswitch0; } 
		  break;
	  case dbg_over_ftrap:	
	    if (loc.h&sign_bit) 
			tracing=interact_after_break=false;
		else
		  { dbg_mode=dbg_step; goto reswitch0; } 
		break;

After having performed a RESUME and the next instruction back in user
space, we resume tracing and possibly interacting 	
	   case dbg_over_ftrap:	
	    if ((inst>>24)==RESUME && (inst_ptr.h&sign_bit)==0)
		{ fetch_traced=tracing=true, interact_after_break=break_after;
		  loc=trap_loc;
          dbg_mode=dbg_step;
		}
		else 
		  tracing=interact_after_break=false;
        break;

Now we consider the case when break_after==false
We discover thos situation after tracing the instruction.
Using the same code as before.		
	  case dbg_over:
	    if ((inst>>24)==TRAP && (loc.h&sign_bit)==0)
		  {  dbg_mode=dbg_over_ftrap;
		     trap_loc=loc;
             tracing= false; interact_after_break=false;
		  }
		  else
		  { dbg_mode=dbg_step; goto reswitch1; } 
		  break;
		
Next we look at dynamic traps.
When we discover a dynamic trap and the variable
show_operating_system is false, we switch into the
debug mode dbg_over_dtrap.
It will ignore all instructions from the operating system and return to normal operations after the final resume.

when we get a dynamic trap, we switch to dbg_over_dtrap mode:		
if (mmix_dynamic_trap() && !show_operating_system)
{ dtrap_mode=dbg_mode;
  dbg_mode=dbg_over_dtrap;
}

We return to the previous mode when we are back in user space otherwise we do not trace or interact.

after fetch:		
	  case dbg_over_dtrap:
		 if (loc.h&sign_bit) 
			tracing=interact_after_break=false;
		else
		  { dbg_mode=dtrap_mode; goto reswitch0; }
		break;
	
after perform:	
		
	  case dbg_over_dtrap:
		tracing=interact_after_break=false;
		break;


----------------------------

medium old loop:
    bool fetch_traced=false;
	octa out_loc;

	if (dbg_mode==dbg_quit)	goto end_simulation; 

	mmix_fetch_instruction();
#ifndef VMB
interact:
#endif

    /* decide on tracing and interacting based on dbg mode*/
	switch (dbg_mode)
	{ case dbg_step:
	    tracing=interact_after_break=true;
	    break;
	  default:
        tracing=interact_after_break=false;
		break;
	}

	if (tracing) 
	{ mmix_trace_fetch(); fetch_traced=true;}

	if (interacting && !break_after && interact_after_break)
	{ mmix_stopped(loc);
	  mmix_interact();
	} 

resume:
    mmix_perform_instruction(); 
	switch (dbg_mode)
	{ 
	  default:
		break;
	}
	if (tracing)
	{ if (!fetch_traced) 
	  { mmix_trace_fetch(); fetch_traced=true; }
      mmix_trace_perform();
	  if (showing_stats) show_stats(breakpoint);
	}


	/* mmix_trace(); */
#ifdef VMB
	mmix_dynamic_trap();
#endif
    if (resuming)
	{ if (op==RESUME)
	    goto resume;
	  else
	    resuming=false;
	}

if (interacting && interact_after_break)
   {	
			mmix_interact();
    }

	if (
#ifdef VMB
		!vmb.power || vmb.reset_flag ||
#endif
		(g[rQ].l&g[rK].l&RE_BIT))
    { breakpoint|=trace_bit; 
      goto boot;
    }
		  Sleep(10);  /* to give the ide time to update the screen while debugging */
  }
Old loop:
   bool fetch_traced=false;
	octa out_loc;

	if (dbg_mode==dbg_quit)	goto end_simulation; 

	mmix_fetch_instruction();
#ifndef VMB
interact:
#endif

    /* decide on tracing and interacting based on dbg mode*/
	switch (dbg_mode)
	{ case dbg_step:
	    tracing=interact_after_break=true;
	    break;
	  case dbg_over:
	    tracing=true;
		interact_after_break=false;
		if ((inst>>24)==TRAP) 
			dbg_mode=dbg_over_ftrap;
		break;
	  case dbg_over_ftrap:
		  if (loc.h&sign_bit)
		     tracing=interact_after_break=false;
		  else
		  { tracing=interact_after_break=true;
		    dbg_mode=dbg_step;
		  }
        break;
	  case dbg_cont:
	  default:
        tracing=interact_after_break=false;
		break;
	}
 	if (breakpoint&exec_bit)  
		tracing=interact_after_break=true;
	if (breakpoint & trace_bit) 
		tracing=true;
	if (interrupt) 
		interacting=tracing=interact_after_break=true, interrupt=false;

	if ((loc.h&sign_bit) && !show_operating_system) tracing=interact_after_break=false; 


	if (tracing) 
	{ mmix_trace_fetch(); fetch_traced=true;}

	if (interacting && !break_after && interact_after_break)
	{ mmix_stopped(loc);
	  mmix_interact();
	} 

resume:
    mmix_perform_instruction(); 
	switch (dbg_mode)
	{ case dbg_over:
		if ((inst>>24)==TRAP) 
			dbg_mode=dbg_over_ftrap;
		break;
     case dbg_over_ftrap:
		if (!(inst_ptr.h&sign_bit)) 
		{  tracing=interact_after_break=true;
          dbg_mode=dbg_step;
		}
		break;
	  default:
		break;
	}
    if (dbg_mode==dbg_step)
	{ if (!is_traceable(inst_ptr))
	  { dbg_mode=dbg_out;
	    out_loc=loc;
	    interact_after_break=false;
	  }
	  else
	    mmix_stopped(loc);
	}

	if (tracing)
	{ if (!fetch_traced) 
	  { mmix_trace_fetch(); fetch_traced=true; }
      mmix_trace_perform();
	  if (showing_stats) show_stats(breakpoint);
	}


	/* mmix_trace(); */
#ifdef VMB
	mmix_dynamic_trap();
#endif
    if (resuming)
	{ if (op==RESUME)
	    goto resume;
	  else
	    resuming=false;
	}

if (interacting && break_after && interact_after_break)
   {	
			mmix_interact();
    }

	if (
#ifdef VMB
		!vmb.power || vmb.reset_flag ||
#endif
		(g[rQ].l&g[rK].l&RE_BIT))
    { breakpoint|=trace_bit; 
      goto boot;
    }
		  Sleep(10);  /* to give the ide time to update the screen while debugging */
  }