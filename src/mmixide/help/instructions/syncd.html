<head>
    <link rel="stylesheet" type="text/css" href="../mmixide.css">
</head>
<body>

    <h4>SYNCD</h4>
    <Object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
        <param name="Keyword" value="SYNCD">
    </OBJECT>



    <B>Name:</B>
    <p>
        <a name="SYNCD" id="SYNCD">SYNCD</a> X,$Y,$Z
    <p>
        <B>Timing:</B>
    <p>
        SYNCD: &upsilon;
    <p>
        <B>Description:</B>
    <p>
        Synchronize data cache und main memory in the region
        $Y+$Z to X+$Y+$Z.
    <p>
    <table border=1 cellspacing="4" cellpadding="4">
        <tr><td>SYNCD:</td> 
            <td><i>"Synchronize data"</i> <br>When executed from nonnegative locations, these instructions have no effect on registers or memory if neither
                a write buffer nor a "write back" data cache are present. But when such a buffer or cache exists, they force
                the computer to make sure that all data for the X+1 bytes M[$Y+$Z] through M[$Y+$Z+X], or M[$Y+Z]
                through M[$Y + Z + X], will be present in memory. (Otherwise the result of a previous store instruction
                might appear only in the cache; the computer is being told that now is the time to write the information
                back, if it hasn't already been written. A program can use this feature before outputting directly from
                memory.) No protection failure occurs if the memory is not accessible.<br>
                The action is similar when SYNCD is executed from a negative address, but in this case the specified bytes
                are also removed from the data cache (and from a secondary cache, if present). The operating system can
                use this feature when a page of virtual memory is being swapped out, or when data is input directly into
                memory.</tr>
    </table>
</p>

</body>
